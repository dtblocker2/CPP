# Recursion Practice: Rope Cutting and Digit Sum

## 1. **Maximum Rope Pieces (Recursive Approach)**

**Problem:**
- Given a rope of length $$ n $$, and allowed piece lengths $$ a, b, c $$, cut the rope into the maximum number of pieces, each of length $$ a $$, $$ b $$, or $$ c $$.
- If not possible, return $$ -1 $$.

**Examples:**
- $$ n = 5,\ a = 2,\ b = 5,\ c = 1 $$ → Output: 5 (all pieces of length 1)
- $$ n = 23,\ a = 12,\ b = 9,\ c = 11 $$ → Output: 2 (pieces: 12 and 11)
- $$ n = 5,\ a = 4,\ b = 2,\ c = 6 $$ → Output: -1 (no valid cuts)

**Recursive Idea:**
- At each step, try cutting a piece of length $$ a $$, $$ b $$, or $$ c $$.
- For each cut, recursively solve for the remaining rope length.
- Base cases:
  - If $$ n = 0 $$: return 0 (no rope left, valid solution).
  - If $$ n < 0 $$: return $$ -1 $$ (invalid, over-cut).
- For each call, take the maximum among the three options. If all are $$ -1 $$, return $$ -1 $$; otherwise, add 1 to the maximum (for the current cut).

**Pseudocode:**
```python
# Returns max number of pieces, or -1 if not possible
def max_pieces(n, a, b, c):
    if n == 0:
        return 0
    if n < 0:
        return -1
    res_a = max_pieces(n - a, a, b, c)
    res_b = max_pieces(n - b, a, b, c)
    res_c = max_pieces(n - c, a, b, c)
    max_res = max(res_a, res_b, res_c)
    if max_res == -1:
        return -1
    return max_res + 1
```

**Key Points:**
- Always check all three options at each step.
- Only add 1 if at least one recursive call is valid (not $$ -1 $$).
- This is a classic example of recursion with multiple choices and base cases for both success and failure.

**Complexity:**
- Worst-case time: $$ O(3^n) $$ (exponential, since each call can branch three ways).
- Can be improved with dynamic programming (memoization).

***

## 2. **Sum of Digits (Recursive Approach)**

**Problem:**
- Given a non-negative integer $$ n $$, return the sum of its digits.
- Example: $$ n = 253 $$ → Output: 10 (2+5+3)

**Recursive Idea:**
- At each step, add the last digit ($$ n \% 10 $$) to the sum of digits of the number without the last digit ($$ n // 10 $$).
- Base case: If $$ n = 0 $$, return 0.

**Pseudocode:**
```python
def sum_digits(n):
    if n == 0:
        return 0
    return sum_digits(n // 10) + (n % 10)
```

**Optimized Base Case:**
- If you want to avoid an extra call for single-digit numbers:
```python
def sum_digits(n):
    if n <= 9:
        return n
    return sum_digits(n // 10) + (n % 10)
```

**Complexity:**
- Time: $$ O(d) $$, where $$ d $$ is the number of digits in $$ n $$.
- Space: $$ O(d) $$ (call stack).

**Iterative Alternative:**
- Iterative solutions are more efficient (no call stack overhead):
```python
def sum_digits_iter(n):
    res = 0
    while n > 0:
        res += n % 10
        n //= 10
    return res
```

***

## 3. **Key Recursion Takeaways**
- Always define clear base cases for both success and failure.
- For problems with multiple choices (like rope cutting), try all options and combine results appropriately.
- For digit-based problems, recursion often works by removing one digit at a time (usually the last digit).
- Iterative solutions are often more efficient for simple digit problems, but recursion is valuable for learning and for problems with branching choices.

***

**Practice:**
- Try writing a recursive function for the coin change problem (number of ways to make change for $$ n $$ using given coin denominations).
- Can you adapt the rope cutting recursion to use memoization for better performance?

If you want to see a dry run of either function or discuss dynamic programming improvements, just ask!

# Recursion Practice: Subsets and Palindrome Check

## 1. Generating All Subsets (Subsequences) of a String

**Problem:**
- Given a string of length $$ n $$ with distinct characters, generate all possible subsets (subsequences).
- Each subset is formed by including or excluding each character, keeping the order.
- There are $$ 2^n $$ possible subsets, including the empty string.

**Recursive Idea:**
- At each character, you have two choices: include it in the current subset, or exclude it.
- Use a helper function with parameters: the original string, the current subset (initially empty), and the current index.
- Base case: When the index reaches the string's length, print the current subset.

**Pseudocode:**
```python
# s: original string, curr: current subset, i: current index
def generate_subsets(s, curr, i):
    if i == len(s):
        print(curr)  # or store in a list
        return
    # Exclude s[i]
    generate_subsets(s, curr, i+1)
    # Include s[i]
    generate_subsets(s, curr + s[i], i+1)
# Call with generate_subsets(s, "", 0)
```

**Example ("abc"):**
- Output: "", "a", "b", "ab", "c", "ac", "bc", "abc"
- Each subset is generated by traversing the recursion tree, making two choices at each step.

**Complexity:**
- Time: $$ O(2^n) $$ (each subset generated)
- Space: $$ O(n) $$ (call stack depth)

***

## 2. Recursive Palindrome Check for Strings

**Problem:**
- Given a string, check if it is a palindrome using recursion.
- A palindrome reads the same forwards and backwards.

**Recursive Idea:**
- Compare the first and last characters.
- If they match, recursively check the substring excluding those characters.
- Base cases:
  - If the substring length is 0 or 1, return True (empty or single character is a palindrome).
  - If the first and last characters do not match, return False.

**Pseudocode:**
```python
# s: string, start: left index, end: right index
def is_palindrome(s, start, end):
    if start >= end:
        return True
    if s[start] != s[end]:
        return False
    return is_palindrome(s, start+1, end-1)
# Call with is_palindrome(s, 0, len(s)-1)
```

**Key Points:**
- The function checks characters from the outside in, reducing the problem size by 2 each call.
- Short-circuit logic: If any pair doesn't match, return False immediately.

**Complexity:**
- Time: $$ O(n) $$ (each character checked once)
- Space: $$ O(n) $$ (call stack depth up to $$ n/2 $$)

***

## 3. Summary Table
| Problem                | Recursive Approach         | Base Case(s)           | Complexity |
|------------------------|---------------------------|------------------------|------------|
| Subsets of String      | Include/exclude each char | Index == length        | $$ O(2^n) $$ |
| Palindrome Check       | Compare ends, recurse     | start >= end, mismatch | $$ O(n) $$   |

***

**Practice:**
- Try writing the subset generator for a string of length 4. How many outputs do you get?
- For palindrome check, what happens for an empty string or a single character?

If you want to see dry runs, code in a specific language, or more recursion patterns, let me know!

# Recursion Practice: String Permutations

## 1. **Problem Statement**
- Given a string of length $$ n $$, print all possible permutations of its characters.
- Example: For "ABC", output is: ABC, ACB, BAC, BCA, CAB, CBA.
- Number of permutations: $$ n! $$ (factorial of $$ n $$).

## 2. **Recursive Idea**
- At each step, fix one character at the current position (index $$ i $$), then recursively permute the remaining characters.
- Use a loop to swap each character into position $$ i $$, then recursively permute the rest.
- After recursion, swap back to restore the original string (backtracking).

## 3. **Pseudocode**
```python
# s: list of characters, i: current index
# Call with permute(s, 0)
def permute(s, i):
    if i == len(s) - 1:
        print(''.join(s))
        return
    for j in range(i, len(s)):
        s[i], s[j] = s[j], s[i]  # Swap
        permute(s, i + 1)
        s[i], s[j] = s[j], s[i]  # Swap back (backtrack)
```
- In C++/Java, use string or char array and swap characters at positions $$ i $$ and $$ j $$.
- The base case is when $$ i $$ reaches the last index; print the current permutation.

## 4. **How It Works (Dry Run for "ABC")**
- Start with i=0:
  - Swap A with A, permute("ABC", 1)
    - Swap B with B, permute("ABC", 2) → print "ABC"
    - Swap B with C, permute("ACB", 2) → print "ACB"
  - Swap A with B, permute("BAC", 1)
    - Swap A with A, permute("BAC", 2) → print "BAC"
    - Swap A with C, permute("BCA", 2) → print "BCA"
  - Swap A with C, permute("CBA", 1)
    - Swap B with B, permute("CBA", 2) → print "CBA"
    - Swap B with A, permute("CAB", 2) → print "CAB"

## 5. **Key Points**
- The loop inside recursion allows fixing each character at the current position.
- Swapping back after recursion ensures the original string is restored for the next iteration (backtracking).
- The recursion tree explores all possible orderings.

## 6. **Complexity**
- Time: $$ O(n!) $$ (all permutations generated)
- Space: $$ O(n) $$ (call stack depth)

***

**Practice:**
- Try writing the permutation function for a string of length 4. How many outputs do you get?
- Why is swapping back necessary after each recursive call?

If you want to see code in a specific language or a dry run for a longer string, let me know!