Here are the notes from the video on recursion.

## Introduction to Recursion

  * **Definition:** Recursion is a problem-solving technique where a function calls itself, either directly or indirectly.
  * **Prerequisite:** A clear understanding of how standard function calls work is essential before tackling recursion.

-----

## How Function Calls Work

The video explains the execution flow using an example where `main` calls `fun2`, and `fun2` calls `fun1`.

1.  Execution always begins in the `main` function.
2.  When `main` calls `fun2`, `main` pauses its execution and waits.
3.  `fun2` begins executing.
4.  When `fun2` calls `fun1`, `fun2` also pauses and waits.
5.  `fun1` executes all its code and finishes.
6.  Control returns to `fun2`, which resumes execution from where it left off.
7.  Once `fun2` finishes, control returns to `main`.
8.  `main` resumes and finishes, ending the program.

<!-- end list -->

  * **Key Principle:** This process follows a stack (Last-In, First-Out) model. The last function called (`fun1`) is the first one to finish.

-----

## Types of Recursion

  * **Direct Recursion:** A function (`fun1`) calls itself directly from within its own code. This is the most common type and the focus of the video.
  * **Indirect Recursion:** A function (`fun1`) calls another function (`fun2`), which then calls `fun1`.

-----

## The Problem: Infinite Recursion

The video shows an initial "wrong" example where a function `fun1` simply prints "GFG" and then calls `fun1()` without any conditions.

  * **Problem:** The function has no **termination condition** (or "base case"), so it calls itself endlessly.
  * **Result:** The program runs out of memory allocated for function calls.
      * In **C++**, this typically causes a **Segmentation Fault**.
      * In **Java**, this causes a **Stack Overflow Error**.

-----

## The Solution: Base Cases

To fix infinite recursion, you must provide a condition to stop the recursive calls.

  * **Base Case:** A condition within the recursive function that does *not* make another recursive call, allowing the function to return.
  * **Corrected Example:** A function `fun1(int n)` is introduced.
    1.  **Base Case:** `if (n == 0) { return; }`
    2.  **Recursive Step:** If `n` is not 0, the function prints "GFG" and then calls itself with a modified parameter: `fun1(n - 1)`.

### Execution Trace (Example: `fun1(2)`)

1.  `main` calls `fun1(2)`.
2.  **`fun1(2)`:** `n` is not 0. Prints "GFG". Calls `fun1(1)`. (Waits)
3.  **`fun1(1)`:** `n` is not 0. Prints "GFG". Calls `fun1(0)`. (Waits)
4.  **`fun1(0)`:** `n` *is* 0. Hits the base case and `return`s.
5.  **`fun1(1)`:** Resumes, has no more code to run, and `return`s.
6.  **`fun1(2)`:** Resumes, has no more code to run, and `return`s.
7.  `main` resumes.

<!-- end list -->

  * **Final Output:**
    ```
    GFG
    GFG
    ```

-----

## Typical Structure of a Recursive Function

A typical recursive function has two main parts:

1.  **Base Case(s):** One or more terminating conditions that stop the recursion.
2.  **Recursive Call:** The function calls itself, but with **at least one parameter changed**. This change must move the parameter closer to the base case (e.g., `n` becomes `n-1`, moving towards 0).