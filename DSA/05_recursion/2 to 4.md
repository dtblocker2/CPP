# Recursion Practice: Print Numbers, Logarithms, Binary, and Output Tracing

## 1. Print Numbers from 1 to n (Recursion)

**Problem:** Print all numbers from 1 to $$ n $$ using recursion.

**Recursive Idea:**
- To print $$ 1, 2, \ldots, n $$, first print numbers from $$ 1 $$ to $$ n-1 $$ recursively, then print $$ n $$.
- Base case: If $$ n = 0 $$, stop (do not print).

**Pseudocode:**
```python
# Python-like pseudocode
def print_1_to_n(n):
    if n == 0:
        return
    print_1_to_n(n-1)
    print(n)
```
**Execution for $$ n = 4 $$:**
- Calls: print_1_to_n(4) → print_1_to_n(3) → print_1_to_n(2) → print_1_to_n(1) → print_1_to_n(0)
- Prints: 1, 2, 3, 4 (in order)

**Complexity:**
- Time: $$ \Theta(n) $$
- Space: $$ \Theta(n) $$ (call stack)

***

## 2. Recursive Function: Counting Log Base 2

**Function:**
- For input $$ n $$, repeatedly divide by 2 until reaching 1, counting the steps.
- Returns $$ \lfloor \log_2 n \rfloor $$ (the exponent of the largest power of 2 $$ \leq n $$).

**Pseudocode:**
```python
def log2_floor(n):
    if n == 1:
        return 0
    return 1 + log2_floor(n // 2)
```
**Example:**
- $$ n = 16 $$: Calls for 8, 4, 2, 1 → returns 4 (since $$ 2^4 = 16 $$).
- $$ n = 31 $$: Calls for 15, 7, 3, 1 → returns 4 (since $$ 2^4 = 16 < 31 < 32 = 2^5 $$).

**Generalization:**
- For base $$ b $$, change division and base case:
```python
def logb_floor(n, b):
    if n < b:
        return 0
    return 1 + logb_floor(n // b, b)
```

***

## 3. Recursive Function: Print Binary Representation

**Function:**
- For input $$ n > 0 $$, recursively print the binary digits (from most significant to least).
- At each step, print $$ n \% 2 $$ after recursive call for $$ n // 2 $$.

**Pseudocode:**
```python
def print_binary(n):
    if n == 0:
        return
    print_binary(n // 2)
    print(n % 2)
```
**Example:**
- $$ n = 13 $$: Calls for 6, 3, 1, 0 → prints 1, 1, 0, 1 (output: 1101)
- This matches the binary representation of 13.

**Key Insight:**
- This recursion prints the binary digits in correct order (MSB to LSB).
- The process is equivalent to repeated division by 2 and collecting remainders.

***

## 4. Output Tracing: Nested Recursion and Print Order

### Example 1: Print Pattern

**Function:**
- Print $$ n $$, call recursively for $$ n-1 $$, then print $$ n $$ again.

**Pseudocode:**
```python
def fun(n):
    if n == 0:
        return
    print(n)
    fun(n-1)
    print(n)
```
**For $$ n = 3 $$:**
- Output: 3 2 1 1 2 3
- Explanation: Prints descending, then ascending.

### Example 2: More Complex Pattern

**Function:**
- For $$ n $$, call recursively for $$ n-1 $$, print $$ n $$, call again for $$ n-1 $$.

**Pseudocode:**
```python
def fun(n):
    if n == 0:
        return
    fun(n-1)
    print(n)
    fun(n-1)
```
**For $$ n = 3 $$:**
- Output: 1 2 1 3 1 2 1
- Explanation: Each call prints left subtree, then root, then right subtree (like in-order traversal).

***

## 5. Key Recursion Concepts

- **Base Case:** Always needed to stop recursion and avoid stack overflow.
- **Recursive Step:** Reduce problem size, call function on smaller input.
- **Print Order:** Placement of print statements (before/after recursion) affects output order.
- **Binary Conversion:** Recursion can be used to print binary digits in correct order.
- **Logarithmic Counting:** Recursion can count steps in repeated division, giving logarithms.

***

**Quick Practice:**
- Try writing a recursive function to print numbers from $$ n $$ down to 1.
- Trace the output of a function that prints before and after the recursive call.
- Write a function to print the binary representation of any positive integer.

If you want to see more code examples, dry runs, or practice problems, let me know your preferred language or a specific recursion pattern!