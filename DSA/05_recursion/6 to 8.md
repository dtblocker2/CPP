# Detailed Notes: Recursion, Base Cases, and Tail Recursion

## 1. Printing Numbers from n to 1 Recursively

**Problem:**
- Write a recursive function that takes an integer $$ n \geq 1 $$ and prints all integers from $$ n $$ down to 1.
- Example: If $$ n = 5 $$, output is `5 4 3 2 1`.

**Recursive Thinking:**
- To print from $$ n $$ to 1, print $$ n $$ first, then recursively print from $$ n-1 $$ to 1.
- The function reduces the problem size by 1 each call.

**Base Case:**
- Stop when $$ n = 0 $$. Do not print anything for $$ n = 0 $$.
- This prevents infinite recursion and stack overflow.

**Pseudocode:**
```python
# Python-like pseudocode
def print_n_to_1(n):
    if n == 0:
        return
    print(n)
    print_n_to_1(n-1)
```

**Execution Example (n=4):**
- print 4, call for 3
- print 3, call for 2
- print 2, call for 1
- print 1, call for 0 (stops)

**Time Complexity:**
- $$ \Theta(n) $$: Each call does constant work and makes one recursive call.

**Auxiliary Space:**
- $$ \Theta(n) $$: Each call waits for its child to finish, so the call stack grows to $$ n+1 $$ at its deepest.

***

## 2. Writing Base Cases in Recursion

**Why are base cases important?**
- Base cases stop recursion from continuing forever.
- They handle the smallest subproblems that cannot be broken down further.
- Without correct base cases, you risk stack overflow or segmentation faults.

### Example 1: Factorial
- $$ \text{factorial}(n) = n \times \text{factorial}(n-1) $$
- **Base case:** $$ \text{factorial}(0) = 1 $$
- If you use the wrong base case (e.g., only $$ n=1 $$), calling $$ \text{factorial}(0) $$ will recurse forever into negative numbers.

**Pseudocode:**
```python
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n-1)
```

### Example 2: Fibonacci
- $$ \text{fib}(n) = \text{fib}(n-1) + \text{fib}(n-2) $$
- **Base cases:** $$ \text{fib}(0) = 0 $$, $$ \text{fib}(1) = 1 $$
- Both are needed! If you only use $$ n=0 $$, then $$ \text{fib}(1) $$ will call $$ \text{fib}(0) $$ and $$ \text{fib}(-1) $$, which is invalid.

**Pseudocode:**
```python
def fib(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n-1) + fib(n-2)
# Or, combine:
    if n <= 1:
        return n
```

**Key Point:**
- Always check which values your recursion will reach, and ensure all are handled by base cases.

***

## 3. Tail Recursion

**Definition:**
- A function is *tail recursive* if the last operation is the recursive call, and the caller has nothing left to do after the call returns.
- Example: Printing from $$ n $$ to 1 is tail recursive, because after the recursive call, nothing else happens.

**Why is tail recursion important?**
- Modern compilers can optimize tail recursive functions by reusing the same stack frame (tail call elimination), reducing auxiliary space to $$ \Theta(1) $$.
- Non-tail recursive functions cannot be optimized this way, so they use more stack space.

**Example: Print 1 to n (non-tail vs tail recursive)**

- **Non-tail recursive:**
```python
def print_1_to_n(n):
    if n == 0:
        return
    print_1_to_n(n-1)
    print(n)
```
- After the recursive call, you still need to print $$ n $$, so it's not tail recursive.

- **Tail recursive (with extra parameter):**
```python
def print_1_to_n_tail(n, k=1):
    if k > n:
        return
    print(k)
    print_1_to_n_tail(n, k+1)
# Call with print_1_to_n_tail(n, 1)
```
- The last operation is the recursive call, so this is tail recursive.

**Tail Recursion in Factorial:**
- Standard factorial is not tail recursive:
```python
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n-1)
```
- Tail recursive version (with accumulator):
```python
def factorial_tail(n, k=1):
    if n == 0:
        return k
    return factorial_tail(n-1, k*n)
# Call with factorial_tail(n, 1)
```

**Not all functions can be made tail recursive:**
- Some algorithms (like merge sort) require work after recursive calls, so they cannot be converted to tail recursion.

**Summary Table:**
| Function                | Tail Recursive? | Can be Optimized? |
|-------------------------|-----------------|-------------------|
| Print n to 1            | Yes             | Yes               |
| Print 1 to n (basic)    | No              | No                |
| Factorial (basic)       | No              | No                |
| Factorial (with acc.)   | Yes             | Yes               |
| Merge sort              | No              | No                |
| Quicksort (right call)  | Yes (for right) | Yes (for right)   |

***

## 4. Key Takeaways
- **Base cases** are essential for safe recursion. Always check all possible minimal inputs.
- **Tail recursion** allows for compiler optimization, reducing stack usage.
- Not all recursive functions can be made tail recursive, but when possible, prefer tail recursion for efficiency.

***

**Quick Check:**
- Can you write a tail recursive function to sum numbers from 1 to n?
- What happens if you forget a base case in a recursive function?

If you want to see more code examples or practice converting a function to tail recursion, let me know your preferred language or a specific function!